# Launch-файл с переопределениями

В предыдущих сериях мы много говорили об именовании объектов в ROS2: как выглядят корректные названия, каким образом их можно переопределить и передать в качестве параметров. Пример, который мы рассмотрим сегодня, посвящён автоматизации работы с именами с помощью launch-файлов. 

_Примечание_: Launch-система использует собственную терминологию, которая перекликается с основными терминами ROS. Повсюду встречаются знакомые слова, такие как "действия" или "сервисы". Чтобы не возникло путаницы сразу отмечу, что в контексте Launch-системы они имеют другой смысл.

## Архитектура launch-системы

В основе иерархии типов, с которыми может взаимодействовать launch-система, лежит класс LaunchDescriptionEntity. Он определяет единый интерфейс для обхода и развертывания вычислительного графа проекта. 

![ROS abstraction](images/launch_hierachy.svg)

От _LaunchDescriptionEntity_ ведут свою родословную классы _Action_ и _LaunchDescription_. 
LaunchDescription – корневой элемент любого launch-файла, в нём хранится последовательность действий, которая должна быть выполнена в процессе запуска. 

Класс Action описывает общий интерфейс действий. Именно потомки класса _Action_ помещаются в _LaunchDescription_ и исполняются при запуске launch-файла. Все действия, используемые launch-системой распределены между двумя пакетами: launch и launch_ros. В пакете launch хранятся действия общего характера, а launch_ros содержит действия, относящиеся непосредственно к ROS. Мы уже встречались с действием Node, которое позволяет запускает ROS-ноды. 

### Новые действия запуска

Сейчас рассмотрим ещё пару действий. 

**IncludeLaunchDescription** 
&ndash; действие состоит в подключении внешнего экземпляра LaunchDescription к текущий пусковой последовательности. Т.е. с помощью этого действия можно состыковывать между собой различные launch-файлы.

**DeclareLaunchArgument**
&ndash; действие позволяет определить launch-аргумент с собственным именем, его описание и значение по умолчанию. Объявленные таким образом аргументы можно использовать в командной строке или в конфигурационных файлах.

Процессом превращения последовательности действий в исполняемые команды руководит объект типа _LaunchService_ . Он загружает последовательности действий из переданных ему launch-файлов и превращает их в набор событий. События асинхронно обрабатываются в цикле событий, запуская проект. При необходимости _LauchService_ может прервать запуск проекта.

### Подстановки

Действия могут содержать значения, изменяющиеся в процессе запуска проекта (названия нод, значения аргументов командной строки и пр.).  Работа с такими параметрами опирается на механизм подстановок. Подстановки – это объекты, наследующие класс _Substitution_ . Значение подстановки вычисляется в процессе запуска, а необходимая информация может быть получена из конфигурационных файлов, переменных среды, а также при вычислении произвольных выражений на python. Это не замена механизму переопределений, который мы обсуждали в ролике про переопределение имён, а надстройка с расширенным функционалом, которую предоставляет  launch-система.

Существует несколько типов подстановок, мы разберем подстановку _LaunchConfiguration_, которая извлекает строковое значение параметра по его имени из контекста запуска. Контекст запуска представлен объектом класса LaunchContext, который в процессе работы launch-системы постепенно заполняется информацией о параметрах и их значениях.  Именно он обеспечивает  согласованную работу подстановок. 

## Анализ launch-файла joy_teleop_twist
Пора переходить к практике. В прошлой серии мы запускали ноды, связанные с джойстиком с помощью файла teleop-launch. Давайте посмотрим, как он устроен

```bash
find /opt -name teleop-launch.py
vim /opt/ros/humble/share/teleop_twist_joy/launch/teleop-launch.py
```

Файл содержит два действия, запускающих ноду джойстика и ноду преобразования данных. А также 3 действия для объявления конфигурационных параметров, конкретные значения которых будут вычислены в момент запуска с помощью подстановок.


## Собственный launch-файл