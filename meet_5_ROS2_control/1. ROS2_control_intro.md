# ros2_control framework

Примеры

```bash
git clone https://bitbucket.org/theconstructcore/ros2_control_course.git
```


```bash
 apt-get install ros-humble-gazebo-ros2-control
```

## my_robot_bringup

Будем считать, что в пакетах, содержащих слово bringup в названии, лежат конфигурационные файлы для запуска наших роботов.

```bash
cd ~/ros2_ws/src
ros2 pkg create --build-type=ament_cmake my_robot_bringup --dependencies urdf xacro robot_state_publisher
```

Конфигурационный файл для диспетчера контроллеров и алгоритмов управления

```bash
cd ~/ros2_ws/src/my_robot_bringup
mkdir config
```

В каталоге config создаем файл controller_configuration.yaml:

```yaml
# Controller manager configuration
controller_manager:
  ros__parameters:
    update_rate: 10  # Hz

    ### Controllers available
    joint_state_broadcaster:
      type: joint_state_broadcaster/JointStateBroadcaster

    forward_position_controller:
      type: forward_command_controller/ForwardCommandController

    position_trajectory_controller:
      type: joint_trajectory_controller/JointTrajectoryController


### Properties of the controllers that we will use and definition of joints to use ###
forward_position_controller:
  ros__parameters:
    joints:
      - joint1
    interface_name: position


position_trajectory_controller:
  ros__parameters:
    joints:
      - joint1

    command_interfaces:
      - position

    state_interfaces:
      - position

    state_publish_rate: 200.0 # Hz, Defaults to 50
    action_monitor_rate: 20.0 # Hz, Defaults to 20

    allow_partial_joints_goal: false # Defaults to false
    open_loop_control: true
    allow_integration_in_goal_trajectories: true
    constraints:
      stopped_velocity_tolerance: 0.01 # Defaults to 0.01
      goal_time: 0.0 # Defaults to 0.0 (start immediately)
```

Настраиваем модель робота для работы с контроллерами, подключив фреймворк ros2_control и настраиваем симулятор в качестве источника данных

```xml
  <ros2_control name="MyRobotSystem" type="system">
    
    <hardware>
      <plugin>gazebo_ros2_control/GazeboSystem</plugin>
    </hardware>
    
    <joint name="joint1">
      <command_interface name="position">
        <param name="min">-6.28</param>
        <param name="max">6.28</param>
      </command_interface>
      <state_interface name="position"/>
      <state_interface name="velocity"/>
      <state_interface name="effort"/>
    </joint>
    
  </ros2_control>

  <!-- Gazebo's ros2_control plugin -->
  <gazebo>
    <plugin filename="libgazebo_ros2_control.so" name="gazebo_ros2_control">
      <robot_sim_type>gazebo_ros2_control/GazeboSystem</robot_sim_type>
      <parameters>$(find my_robot_bringup)/config/controller_configuration.yaml</parameters>
    </plugin>
  </gazebo>

```

Добавляем launch-файл для запуска робота
```bash
cd ~/ros2_ws/src/my_robot_bringup
mkdir launch
cd launch
touch my_robot.launch.py
```

```python
import os

from ament_index_python.packages import get_package_share_directory
from launch import LaunchDescription
from launch_ros.actions import Node
from launch.actions import ExecuteProcess, IncludeLaunchDescription, RegisterEventHandler
from launch.event_handlers import OnProcessExit
from launch.launch_description_sources import PythonLaunchDescriptionSource
import xacro


def generate_launch_description():

    rrbot_description_path = os.path.join(
        get_package_share_directory('rrbot_unit2'))

    xacro_file = os.path.join(rrbot_description_path,
                              'urdf',
                              'rrbot.xacro')

    doc = xacro.parse(open(xacro_file))
    xacro.process_doc(doc)
    robot_description_config = doc.toxml()
    robot_description = {'robot_description': robot_description_config}

    node_robot_state_publisher = Node(
        package='robot_state_publisher',
        executable='robot_state_publisher',
        output='screen',
        parameters=[robot_description]
    )

    spawn_entity = Node(package='gazebo_ros', executable='spawn_entity.py',
                        arguments=['-topic', 'robot_description',
                                   '-entity', 'robot'],
                        output='screen')

    joint_state_broadcaster_spawner = Node(
        package="controller_manager",
        executable="spawner",
        arguments=["joint_state_broadcaster",
                   "--controller-manager", "/controller_manager"],
    )

    robot_controller_spawner = Node(
        package="controller_manager",
        executable="spawner",
        arguments=["forward_position_controller", "-c", "/controller_manager"],
    )


    return LaunchDescription([
        RegisterEventHandler(
            event_handler=OnProcessExit(
                target_action=spawn_entity,
                on_exit=[joint_state_broadcaster_spawner],
            )
        ),
        RegisterEventHandler(
            event_handler=OnProcessExit(
                target_action=joint_state_broadcaster_spawner,
                on_exit=[robot_controller_spawner],
            )
        ),
        spawn_entity,
        node_robot_state_publisher,
    ])
```

Обновляем CMakeLists.txt

```cmake
install(
  DIRECTORY
    launch
    config
  DESTINATION
    share/${PROJECT_NAME}/
)
```


Проверка работоспособности 

(https://control.ros.org/master/doc/ros2_control_demos/example_1/doc/userdoc.html)


```bash
ros2 topic list
```

```bash
ros2 topic pub /forward_position_controller/commands std_msgs/msg/Float64MultiArray "data: 
- 0.79" -1
```